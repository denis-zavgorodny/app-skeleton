# Скелет приложения

Набор методов, которые позволяют организовать код.

## namespace()

Модули и функции приложения не захламляют глобальное
пространство имен, а группируются в специально отведенной
для них переменной. Базовое имя задается в константе **NS**.

    App.namespace("App.Module1");

Можно использовать укороченный синтаксис, чтобы получить аналогичный результат:

    App.namespace("Module1");

Второй опциональный параметр задает исходный объект, который
нужно расширить существующими полями и методами, если они уже есть.

    App.namespace("App.Module1", {
        field: "field 1",
        method: function (a, b) {
            return a + b;
        }
    });

Метод может быть вызван без параметров. Тогда он вернет глобальный
объект приложения

    App.namespace() === App    /* true */

## defaults()

Вспомогательный метод для доступа к хранилищу настроек компонент приложения.
Его поведение полностью аналогично `namespace` за исключением того, что
данные сохраняются и извлекаются не из глобальной меременной, а из локальной.

    App.defauls("Module1", {url: "/search/"});

Если `defaults` вызвать без параметров, то можно получить доступ ко всем
сохраненным ранее данным.

Основное применение этого метода заключается в том, что приложение
может объявлять настройки отдельных компонент до их загрузки и инициализации.
В дальнейшем такие компоненты при инициализации должны будут обратиться к
этому хранилищу и получить их.

## module()

Функция возвращает новый объект, поля и методы которого унаследованы
от исходного. Подробнее о схеме работы можно прочесть в статье
Дугласа Крокфорда «[Наследование через прототип](http://javascript.crockford.com/prototypal.html)».

    var M = App.module({
        method: function (a, b) {
            return a + b;
        }
    });

    App.namespace("App.Module", M);

# App.Dependency

Модуль для хранения зависимостей компонент приложения друг от друга

## add()

Добавляем компоненту

    App.Dependency.add({
        // имя компоненты, которое в дальнейшем будет использоваться
        // при построении списка зависимостей
        name: "module1",
        // путь до файла компоненты
        path: "/scripts/module1.js",
        // список зависимостей. порядок следования определяет приоритет загрузки
        // может быть пустым или отсутствовать вообще
        requires: ["jQuery", "common", "module2"]
    });

## calculate()

Построение списка компонент, от которых зависит данный модуль

    var list = App.Dependency.calculate("module1");

В результате работы получаем массив со значениями `path`, отсортированный в порядке
значимости.
